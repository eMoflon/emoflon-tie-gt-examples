import "platform:/resource/GraphOperations/model/GraphOperations.ecore"
import "http://www.eclipse.org/emf/2002/Ecore"

pattern pNodeExists(nodeId: EString) {
  node: Node {
    .id == param::nodeId
  }

  graph: Graph {
    -nodes -> node
  }
}

pattern pNodeExistsRef() {
  node: Node

  graph: Graph {
    -nodes -> node
  }
}

rule pCreateNode(nodeId: EString) {
  ++ newNode: Node {
    .id := param::nodeId
  }

  graph: Graph {
    ++ -nodes -> newNode
  }
}

rule addNode() {
  node : Node

  graph: Graph {
    ++ -nodes -> node
  }
}

rule createEdge(edgeId: EString) {
  graph: Graph

  srcNode: Node {
    -graph -> graph
  }

  trgNode: Node

  ++edge: Edge {
    .id := param::edgeId
    ++ -source -> srcNode
    ++ -target -> trgNode
    ++ -graph -> graph
  }
}

rule removeEdge(edgeId: EString) {
  graph: Graph

  -- edge: Edge {
    .id == param::edgeId
    -- -graph -> graph
  }
}

rule removeEdgeRef() {
  -- edge: Edge
}

rule removeNodeRef() {
  -- node: Node
}

pattern pOutgoingEdge() {
  edge: Edge

  node: Node {
    -outgoingEdges -> edge
  }
}

pattern pIncomingEdge() {
  edge: Edge

  node: Node {
    -incomingEdges -> edge
  }
}

rule initializeEIntContainer() {
  ++ container: EIntContainer {
    .value := 0
  }
}

pattern isNodePattern() {
  element: Element

  node: Node := element
}

pattern outgoingEdge() {
  outgoingEdge: Edge

  node: Node {
    -outgoingEdges -> outgoingEdge
  }
}

pattern incomingEdge() {
  incomingEdge: Edge

  node: Node {
    -incomingEdges -> incomingEdge
  }
}

pattern isolatedNode() {
  graph: Graph

  node: Node {
    -graph -> graph
  }
}
when noIncidentEdges

condition noIncidentEdges = forbid outgoingEdge && forbid incomingEdge

pattern someElement {
  graph: Graph

  element: Element
}

pattern someNode
refines someElement {
  element: Node {
    -graph -> graph
  }
}

pattern someEdge
refines someElement {
  element: Node {
    -graph -> graph
  }
}

rule triangleWithLongestEdge() {
  graph: Graph

  n1: Node

  n2: Node

  n3: Node

  longestEdge: Edge {
    .weight > shorterEdge1.weight
    .weight > shorterEdge2.weight
    -graph -> graph
    -source -> n1
    -target -> n2
  }

  shorterEdge1: Edge {
    .weight >= shorterEdge2.weight
    -graph -> graph
    -source -> n1
    -target -> n3
  }

  shorterEdge2: Edge {
    .weight < longestEdge.weight
    -graph -> graph
    -source -> n3
    -target -> n2
  }

  ++ triangle: Triangle {
    ++ -longEdge -> longestEdge
    ++ -shortEdges -> shorterEdge1
    ++ -shortEdges -> shorterEdge2
  }
}

attributeConditionLibrary {
  eqI(x : EInt, y : EInt) {
    check [B B] {
      Java : '${x} == ${y}'
    }
    extend [F B] {
      Java : '${x} = ${y}'
    }
    extend [B F] {
       Java : '${y} = ${x}'
    }
  }
  eqL(x : ELong, y : ELong) reuse eqI
  eqF(x : EFloat, y : EFloat) reuse eqI
  eqD(x : EDouble, y : EDouble) reuse eqI
  eqShort(x : EShort, y : EShort) reuse eqI
  eqByte(x : EByte, y : EShort) reuse eqI
  
  eqS(x : EString, y : EString) {
    check [ B B ] {
      Java : '${x} == null ? ${y} == null : {x}.equals(${y})'
    }
    extend [F B] {
      Java : '${x} = ${y}'
    }
    extend [B F] {
       Java : '${y} = ${x}'
    }
  }
  
}

/*
 * Task list for CACs
 * * enum expressions
 * * validation: parameter (count, type)
 * 
 * Library:
 * * adornment matches parameter specification (length)
 * * only use parameters '${..}' that were declared
 * * for 'reuse': same parameter list, else warning
 */
pattern nodeWithIdCAC {
  graph: Graph

  node: Node {
    -graph -> graph
  }

  edge: Edge {
    -graph -> graph
  }
  attributeCondition {
    x : EInt
    eqS(edge.id, "e12")
    eqS("n1", node.id)
  }
}
