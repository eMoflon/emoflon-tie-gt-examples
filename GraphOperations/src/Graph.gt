import "platform:/resource/GraphOperations/model/GraphOperations.ecore"
import "http://www.eclipse.org/emf/2002/Ecore"

pattern pNodeExists(nodeId: EString) {
  node: Node {
    .id == param::nodeId
  }

  graph: Graph {
    -nodes -> node
  }
}

pattern pNodeExistsRef() {
  node: Node

  graph: Graph {
    -nodes -> node
  }
}

rule pCreateNode(nodeId: EString) {
  ++ newNode: Node {
    .id := param::nodeId
  }

  graph: Graph {
    ++ -nodes -> newNode
  }
}

rule addNode() {
  node : Node

  graph: Graph {
    ++ -nodes -> node
  }
}

rule createEdge(edgeId: EString) {
  graph: Graph

  srcNode: Node {
    -graph -> graph
  }

  trgNode: Node

  ++edge: Edge {
    .id := param::edgeId
    ++ -source -> srcNode
    ++ -target -> trgNode
    ++ -graph -> graph
  }
}

rule removeEdge(edgeId: EString) {
  graph: Graph

  -- edge: Edge {
    .id == param::edgeId
    -- -graph -> graph
  }
}

rule removeEdgeRef() {
  -- edge: Edge
}

rule removeNodeRef() {
  -- node: Node
}

pattern pOutgoingEdge() {
  edge: Edge

  node: Node {
    -outgoingEdges -> edge
  }
}

pattern pIncomingEdge() {
  edge: Edge

  node: Node {
    -incomingEdges -> edge
  }
}

rule initializeEIntContainer() {
  ++ container: EIntContainer {
    .value := 0
  }
}

pattern isNodePattern() {
  element: Element

  node: Node := element
}

pattern outgoingEdge() {
  outgoingEdge: Edge

  node: Node {
    -outgoingEdges -> outgoingEdge
  }
}

pattern incomingEdge() {
  incomingEdge: Edge

  node: Node {
    -incomingEdges -> incomingEdge
  }
}

pattern isolatedNode() {
  graph: Graph

  node: Node {
    -graph -> graph
  }
}
when noIncidentEdges

condition noIncidentEdges = forbid outgoingEdge && forbid incomingEdge

pattern someElement {
  graph: Graph

  element: Element
}

pattern someNode
refines someElement {
  element: Node {
    -graph -> graph
  }
}

pattern someEdge
refines someElement {
  element: Node {
    -graph -> graph
  }
}

rule triangleWithLongestEdge() {
  graph: Graph

  n1: Node

  n2: Node

  n3: Node

  longestEdge: Edge {
    .weight > shorterEdge1.weight
    .weight > shorterEdge2.weight
    -graph -> graph
    -source -> n1
    -target -> n2
  }

  shorterEdge1: Edge {
    .weight >= shorterEdge2.weight
    -graph -> graph
    -source -> n1
    -target -> n3
  }

  shorterEdge2: Edge {
    .weight < longestEdge.weight
    -graph -> graph
    -source -> n3
    -target -> n2
  }

  ++ triangle: Triangle {
    ++ -longEdge -> longestEdge
    ++ -shortEdges -> shorterEdge1
    ++ -shortEdges -> shorterEdge2
  }
}

attributeConditionLibrary {
  eqI(x : EInt, y : EInt) {
    check [B B] {
      Java : '$x$ == $y$'
    }
    extend [F B] {
      Java : '$x$ = $y$'
    }
    extend [B F] {
       Java : '$y$ = $x$'
    }
  }
  eqL(x : ELong, y : ELong) reuse eqI
  eqF(x : EFloat, y : EFloat) reuse eqI
  eqD(x : EDouble, y : EDouble) reuse eqI
  eqShort(x : EShort, y : EShort) reuse eqI
  eqByte(x : EByte, y : EByte) reuse eqI
  
  eqS(x : EString, y : EString) {
    check [ B B ] {
      Java : '$x$ == null ? $y$ == null : $x$.equals($y$)'
    }
    extend [F B] {
      Java : '$x$ = $y$'
    }
    extend [B F] {
       Java : '$y$ = $x$'
    }
  }
  
}

pattern nodeWithIdCAC {
  graph: Graph

  node: Node {
    -graph -> graph
  } 

  attributeCondition {
    //x : EInt
    eqS("n1", node.id)
    eqD(0.0, node.degree)
//    eqS(node.id *, "n1'")
  }
}

